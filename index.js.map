{"version":3,"file":"index.js","sources":["../src/js/pixabay-api.js","../src/js/render-functions.js","../src/main.js"],"sourcesContent":["/*Призначення файлу:Відповідає за взаємодію з API сервісу Pixabay:\n      1.Робить HTTP - запит через axios.\n      2.Надсилає пошуковий запит, який ввів користувач.\n      3.Отримує масив зображень з Pixabay.\n      4.Повертає ці зображення в основний застосунок.*/\n\n// Імпортую бібліотеку для HTTP-запитів, вона спрощує роботу з HTTP-запитами\nimport axios from 'axios';\n\n//Створюю константи для роботи з API Pixabay\nconst API_KEY = '50290691-d51719558e36c91c48babc26d'; // Мій унікальний  API-ключ сервісу Pexibay. Без нього сервер не дозволить зробити запит.\n\nconst BASE_URL = 'https://pixabay.com/api/'; // Базова URL-адреса для запитів, до якого нижче я додаю параметри пошуку (ключ, запит, сторінка тощо)\n\n//Кількість зображень, які отримую за один запит (на одну сторінку)\nconst PER_PAGE = 15;\n\n// Функція для отримання зображень за пошуковим запитом\nexport async function getImagesByQuery(query, page = 1) {\n\n  // перевірка отриманого параметра функції\n  console.log('Виклик функції getImagesByQuery із запитом:', query,page);\n\n  /*Створюю змінну де кладу параметри запиту, які будуть передані у URL.Використовуючи цю змінну, я передаю параметри у функцію axios.get, яка додає їх до запиту в форматі URL-параметрів (query string).*/\n\n  const params = {\n    //змінна приймає об'єкт з усіма параметрами які потрібні до API\n    key: API_KEY,                 // Мій ключ для автентифікації\n    q: query,                    // Пошукове слово, що користувач ввів в пошукове поле\n    image_type: 'photo',        // фільтрую лише зображення\n    orientation: 'horizontal', // Орієнтація зображень-горізогтальна\n    safesearch: true,         // Фільтр для безпечного пошуку\n    per_page: PER_PAGE,      // Максимальна кількість результатів за запитом\n    page: page,             // поточна сторінка\n  };\n\n  //тут я прописую обробку помилки яка може виникнути під час запиту.Відбувається виклик axios.get\n  try {\n    // Виконую GET-запит до API з використанням axios\n    const response = await axios.get(BASE_URL, { params });\n\n    // Повертаю дані (масив зображень hits)\n    return response.data;\n  } catch (error) {\n   \n    // Якщо сталася помилка, викидаю її для обробки на рівні виклику функції\n    throw error;\n  }\n}\n","\n\n/* Файл відповідає за роботу інтерфейсу галереї.\n\n1.createGallery(images) — формує і додає HTML в .gallery.\n2.clearGallery() — очищає HTML в .gallery.\n3.showLoader() / hideLoader() — керують індикатором завантаження.\n4.showLoadMoreButton() / hideLoadMoreButton() — показують або ховають кнопку завантаження.\n5. у файлі ініціалізується SimpleLightbox — бібліотека для модального перегляду зображень.\n*/\n\n\n\n/* Імпорт бібліотеки SimpleLightbox для перегляду зображень у модальному вікні (збільшення за кліком).*/\n\nimport SimpleLightbox from 'simplelightbox';\nimport 'simplelightbox/dist/simple-lightbox.min.css';\n\n// Отримую посилання на DOM-елементи, з якими буде взаємодіяти галерея.\n\n// Знаходжу контейнер для галереї. Щоб надалі працювати з елементами,зберігаю їх у змінних.\nconst galleryContainer = document.querySelector('.gallery'); // Вибираю елемент галереї за класом \"gallery\"\n\n// знаходжу кнопку для пролістування галереі\nconst loadMoreButton = document.querySelector('.select');\n\n// знаходжу індікатор завантаження\nconst loader = document.querySelector('.loader');\n\n// перевірка елемента галереї\n// console.log('Контейнер галереї знайдено:', galleryContainer);\n\nlet lightbox = null; // Змінна для екземпляра SimpleLightbox.Вона буде містить екземпляр бібліотеки SimpleLightbox, щоб оновлювати або ініціалізувати lightbox після рендера.\n// console.log('Ініціалізовано змінну для SimpleLightbox:', lightbox); // перевіряю початкового значення змінної\n\n/* Створює HTML-розмітку для масиву зображень і додає її в контейнер .gallery.\nТакож ініціалізує або оновлює SimpleLightbox для нових елементів.\n 1. Перетворюю кожне зображення з масиву на шматок HTML-коду, щоб відобразити його в галереї.\n 2.Усі згенеровані HTML-елементи вставляються всередину контейнера з класом .gallery, тобто на сторінку.\n 3. Якщо модальне вікно для перегляду зображень (lightbox) уже створене — оновлюю його, щоб показував нові фото. Якщо його ще немає — створюю нове.\n 4.Якщо в галереї вже є зображення — показую кнопку \"Load more\", щоб користувач міг завантажити ще.*/\nexport function createGallery(images) {\n  // Перевіряю отриманий масив зображень\n  console.log('Виклик createGallery. Масив зображень:', images);\n\n  try {\n    // Генерую HTML-розмітку для кожного елемента з масиву зображень\n    const markup = images\n      .map(\n        ({\n          webformatURL, // URL для відображення маленького зображення\n          largeImageURL, // URL для великого зображення\n          tags, // Опис зображення\n          likes, // Кількість лайків\n          views, // Кількість переглядів\n          comments, // Кількість коментарів\n          downloads, // Кількість завантажень\n        }) => {\n          //Виводжу  дані, які обробляються.\n          console.log('Обробка зображення:', {\n            webformatURL,\n            largeImageURL,\n            tags,\n          });\n          return `\n        <li class=\"gallery-item\">\n          <a href=\"${largeImageURL}\" class=\"gallery-link\">\n          <img src=\"${webformatURL}\" alt=\"${tags}\" loading=\"lazy\" />\n          </a>\n        <div class=\"info\">\n        <p><b>Likes:</b> ${likes}</p>\n        <p><b>Views:</b> ${views}</p>\n        <p><b>Comments:</b> ${comments}</p>\n        <p><b>Downloads:</b> ${downloads}</p>\n      </div>\n    </li>`;\n        }\n      )\n\n      //Метод .join('') перетворює масив рядків, отриманих після виконання .map(), в єдиний рядок.\n      .join('');\n\n    // Додаю згенеровану розмітку в контейнер галереї\n    galleryContainer.insertAdjacentHTML('beforeend', markup);\n\n    // Перевіряю чи вже існує екземпляр SimpleLightbox\n    if (lightbox) {\n      lightbox.refresh(); // Якщо так,оновлюю існуючий екземпляр лайтбоксу для нових елементів\n    } else {\n      //створюю новий екземпляр SimpleLightbox\n      lightbox = new SimpleLightbox('.gallery a', {\n        captionsData: 'alt', // Використовую атрибут \"alt\" для підписів зображення\n        captionDelay: 250, // Затримка перед показом підпису\n      });\n\n      //перевіряю створення\n      // console.log('Створено новий екземпляр SimpleLightbox:', lightbox);\n\n      // Показуємо кнопку після додавання зображень\n    }\n    // Показати кнопку \"Load more\" якщо є зображення\n    if (galleryContainer.children.length > 0) {\n      loadMoreButton.classList.remove('is-hidden');\n    }\n   \n  } catch (error) {\n    console.error('Помилка у createGallery:', error);\n    throw error;\n  }\n}\n\n/* Функція для очищення галереї, приховування кнопки \"Loadmore\".\nВидаля. весь вміст галереї перед новим запитом. Також ховаю кнопку \"Load more\", бо вона не потрібна під час нового пошуку. Немає жодної причини бути async. Вона ні чекає нічого з затримкою*/\nexport  function clearGallery() {\n  try {\n    galleryContainer.innerHTML = ''; // видаляю весь HTML-контент с контейнера галереї\n\n    // Сховати кнопку під час нового пошуку\n    hideLoadMoreButton();\n\n    console.log('Галерея очищена.');\n  } catch (error) {\n\n    // Обробка помилок під час очищення\n    console.error('Помилка у функції clearGallery:', error);\n    throw new Error('Не вдалося очистити галерею.');\n  }\n}\n\n/* Функціі для того щоб під час запиту показую лоадер, після завершення — ховаю.\nВони обидві синхронні бо просто забирають і додають клас лоадера в DOM- операціі*/\n\nexport function showLoader() { //керує коли треба показувати лоадер\n  // console.log('Виклик функції showLoader.'); //  виклику функції\n\n  try {\n    //\n    loader.style.display = 'block'; /*Тут я показую що індикатор завантаження (loader) на сторінці.Перед тим, як починаєтся завантажуваня зображення з API, я викликаю цю команду, щоб зрозуміти-йде завантаження.Потім коли завантаження завершується я ховаю лоадер іншою функцією*/\n    console.log('Клас \"loading\" додано до тега <body>.'); // підтвердження додавання класу після невірного вводу\n  } catch (error) {\n    // Обробка помилок під час відображення лоадера\n    console.error('Помилка у функції showLoader:', error);\n    throw new Error('Не вдалося показати лоадер.');\n  }\n}\n\n// Функція для приховування\nexport function hideLoader() {\n  // console.log('Виклик функції hideLoader.'); //  виклик\n  try {\n    loader.style.display = 'none'; //Коли завантаження зображень завершено, я використовую цей рядок, щоб сховати спінер , який показує, що щось завантажується. Елемент буде ніби видалений зі сторінки (але фізично залишиться в коді)\n    // console.log('Клас \"loading\" видалено з тега <body>.'); //  підтвердження видалення класу\n  } catch (error) {\n    // Обробка помилок під час приховування лоадера\n    console.error('Помилка у функції hideLoader:', error);\n    throw new Error('Не вдалося приховати лоадер.');\n  }\n}\n\n/* Кнопка \"Load more\" зʼявляється лише якщо є що завантажити. Коли починаєтьсчя новий пошук — ховаю її. Після успішного завантаження — показую знову.Для куруванням кнопкою додаю дві функціі*/\n//показую кнопку\nexport function showLoadMoreButton() {\n  try {\n    loadMoreButton.classList.remove('is-hidden'); //прибираю клас is-hidden який раніше ховав цю кнопку.Виконується тоді коли зображень більш ніж одна сторінка\n  } catch (error) {\n    console.error('Помилка при показі кнопки Load more:', error);\n    throw error;\n  }\n}\n// Приховати кнопку\nexport function hideLoadMoreButton() {\n  try {\n    loadMoreButton.classList.add('is-hidden'); //додаю клас is-hidden який раніше був знятий.Виконується тоді коли зображень тільки на одну сторінку\n  } catch (error) {\n    console.error('Помилка при приховуванні кнопки Load more:', error);\n    throw error;\n  }\n}\n\n\n\n\n\n\n\n\n","\n /*Що робиться в файлі.\n  При сабміті форми (submit):\n  1. Очищується галерея (щоб не змішувати старі та нові результати) і скидається сторінка (currentPage = 1), одже починаю пошук заново з першої сторінки.\n  2. Запитую першу сторінку результатів за новим пошуковим запитом.\n  3. Показую повідомлення із кількістю знайдених зображень, щоб користувач бачив результат.\n  4. Кнопка Load More робиться видимою, якщо є ще сторінки для завантаження.\n\n При кліку на Load More:\n  1. Запитую наступну сторінку (підвищую currentPage після кожного запиту).\n  2. Додаю нові зображення до галереї, не видаляючи попередні.\n  3. Оновлюю SimpleLightbox (refresh) — щоб нові зображення також відкривались у лайтбоксі.\n  4. Якщо досягнуто останньої сторінки — ховаю кнопку і показую повідомлення.\n  5. Прокрутка сторінки виконується так, щоб користувач бачив новий контент (плавний скрол вниз).\n */\n\n\n// //імпортую функціі.Тут функція робить HTTP-запит і повертає JSON-об'єкт з зображеннями\nimport { getImagesByQuery } from './js/pixabay-api.js';\n/*перевірка на роботу скріпта\nconsole.log('Скрипт main.js працює');\n\ngetImagesByQuery('test').then(data => {\n  console.log('Отримано дані з Pixabay:', data);\n});*/\n\n// функціі для роботи з DOM\nimport {\n  createGallery,          // додає розмітку HTML для зображень\n  clearGallery,          // очищає галерею\n  showLoadMoreButton,   // виводять кнопку \"Load more\"\n  hideLoadMoreButton,  //ховають кнопку\"Load more\"\n} from './js/render-functions.js';  \nimport iziToast from 'izitoast';    // бібліотека для яскравих повідомлень користувачу\nimport 'izitoast/dist/css/iziToast.min.css';  // стилі для iziToast\n\n// шукаю елементи, отримую DOM\nconst form = document.querySelector('.form');                  //форма пошуку\nconst input = form.querySelector('input[name=\"search-text\"]');//поле виведення пошукового текста\nconst loader = document.querySelector('.loader');            // індікатор завантаження\nconst loadMoreButton = document.querySelector('.select');   // кнопка (load more)\nconst gallery = document.querySelector('.gallery');        // контейнер галереї\n\n//Змінні для курування станом пошуку\nlet currentQuery = '';     // поточний пошуковий запит\nlet currentPage = 1;      // номер поточної сторінки пошукового запиту\nlet totalHits = 0;       // загальна кількість знайдених зображень\nlet isLoading = false;  // прапарець щоб уникнути повторного запиту коли один вже триває\n\n// функція для показу індікатора завантаження\nfunction showLoader() {\n  if (loader) loader.style.display = 'block'; //style.display керує видимістю елемента в DOM через CSS.'block' — робить елемент видимим і він займає окремий блок (повний рядок по ширині).//\n  console.log('Loader показано: видимість встановлена на \"block\".'); // Лог для перевірки\n}\n\n//функція для сховування індікатора завантаження.Для того щоб бачити що шось завантажується\nfunction hideLoader() {\n  if (loader) loader.style.display = 'none'; //робить схованим лоадер\n\n  console.log('Loader сховано: видимість встановлена на \"none\".'); // Лог для перевірки\n}\n\n//функція для симуляціі завантаження, чекати завантаження. Я зробив для того щоб при швидкому інтернеті бачити процес завантаження\nasync function delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/* Основна функція для завантаження зображень\n isFirstLoad = true - перший запит (початковий пошук),\nfalse - запит при натисканні Load More. Тобто для блокування повторного виклику*/\nasync function loadImages(isFirstLoad = false) {\n  /* Захист від повторного виклику, якщо запит уже в процесі.Якщо запит уже виконується — не запускаю новий (захист від спаму або \"подвійного кліку\").*/\n  if (isLoading) {\n    console.log('Запит уже виконується, новий запит не запускається.');\n    return;\n  }\n  isLoading = true;\n\n  showLoader(); // показую індікатор що данні завантажені\n  hideLoadMoreButton(); // ховаю кнопку поки не знаю, чи є ще сторінки\n\n  try {\n    await delay(2000); // штучна затримка виконання коду ( для тесту )функціі loadImages\n\n    /* роблю запит до Pixabay за поточним запитом і сторінкою.І отримую список зображеня з сервера.Це основна функція, вона робить всє роботу*/\n    const data = await getImagesByQuery(currentQuery, currentPage);\n\n    //Перевірка чи отримали валідну відповідь\n    if (!data || !Array.isArray(data.hits)) {\n      throw new Error('Невалідна структура відповіді API');\n    }\n    // Якщо немає результатів — очищаємо попередню галерею і повідомляю користувача\n    if (data.hits.length === 0) {\n      clearGallery(); // очищаю галерею\n      iziToast.info({\n        //Виводжу повідомлення\n        title: 'Нічого не знайдено',\n        message:\n          'Sorry, there are no images matching your search query. Please try again!',\n        position: 'topRight',\n      });\n      return;\n    }\n\n    // Якщо це новий запит, очищую старі результати та оновлюю загальну кількість\n    if (isFirstLoad) {\n      clearGallery(); // видаляю старі данні(зображення)\n      totalHits = data.totalHits; // оновлюю загальну кількість знайдених зображень\n      // показую повідомлення про успішний пошук\n      iziToast.success({\n        title: 'Успіх',\n        message: `Знайдено ${totalHits} зображень.`,\n        position: 'topRight',\n      });\n    }\n    createGallery(data.hits); // створюю HTML додаю зображення до галереі\n\n    // Створюю в DOM елементи для отриманих зображень і додаємо їх до галереї\n    createGallery(data.hits);\n\n    //додаю скрол.Зручно бачити що новий контент додано\n    if (isFirstLoad) {\n      // При першому завантаженні скролю сторінку вверх, щоб бачити початок галереї\n      window.scrollTo({\n        top: 0,\n        behavior: 'smooth',\n      });\n    } else {\n      // При подальших завантаженнях скролю вниз, щоб бачити нові картки\n      const firstCard = gallery.querySelector('.photo-card');\n      if (firstCard) {\n        // Визначаю висоту однієї картки, щоб знати, на скільки прокрутити сторінку\n\n        const cardHeight = firstCard.getBoundingClientRect().height || 200; // Висота картки (default 200)\n        const galleryHeight = gallery.scrollHeight;\n\n        // Прокрутка відбувається.На Load More: прокручуємо вниз на висоту однієї картки * 2, щоб користувач побачив нові зображення.\n        if (galleryHeight > window.innerHeight) {\n          window.scrollBy({\n            top: cardHeight * 2,\n            behavior: 'smooth',\n          });\n        }\n      }\n    }\n\n\n    // Обчислюємо максимальну кількість сторінок (по 15 зображень на сторінку)\n    const maxPages = Math.ceil(totalHits / 15);\n\n    // console.log(`Новий запит: \"${currentQuery}\"`);// показую скільки сторінок\n    if (currentPage < maxPages) {\n      currentPage += 1; // переход на іншу сторінку\n      showLoadMoreButton(); // пріказую кнопку\n    } else {\n      hideLoadMoreButton(); // Остання сторінка — ховаємо кнопку\n      //  Якщо ще є зображення — показую кнопку Load More. Якщо ні — ховаю кнопку, інформую користувача.\n      iziToast.info({\n        title: 'Кінець колекції',\n        message: \"We're sorry, but you've reached the end of search results.\",\n        position: 'topRight',\n      });\n    }\n  } catch (error) {\n    // Якщо сталася помилка при запиті — показую повідомлення і лог в консоль\n    console.error('Помилка запиту:', error);\n    iziToast.error({\n      //повідомлення про помилку\n      title: 'Помилка',\n      message: 'Не вдалося завантажити зображення. Спробуйте пізніше.',\n      position: 'topRight',\n    });\n  } finally {\n    // В будь-якому випадку\n    hideLoader(); //ховаю індикатор\n    isLoading = false; // скидаю прапорець завантаження\n  }\n}\n\n// Обробник події сабміту форми\nform.addEventListener('submit', async event => {\n  event.preventDefault(); // відміняю стандартне відправлення форми (щоб не перезавантажувати сторінку)\n\n  // забираю пробіли з початку і кінця\n  const query = input.value.trim();\n\n  // Якщо користувач не ввів запит — показую помилку і виходжу\n  if (!query) {\n    iziToast.error({ // повідомлення якщо порожній запит\n      title: 'Помилка',\n      message: 'Будь ласка, введіть пошуковий запит.',\n      position: 'topRight',\n    });\n    return;\n  }\n\n  // Ініціалізую змінні для нового пошуку\n  currentQuery = query;\n  currentPage = 1;\n  totalHits = 0;\n\n  // Очищаю галерею перед новим запитом\n  clearGallery();\n\n  // Завантажую першу сторінку з новим запитом\n  await loadImages(true); // Очікую виконання запиту та оновлення .Тобто новий запит\n\n  // Очищаю поле вводу, щоб було зручно робити нові пошуки\n  input.value = '';\n});\n\n// Обробник кліку на кнопку Load More.Коли бажаю побачити ще зображення. Нічого не очищається.Додаються зображення.\nloadMoreButton.addEventListener('click', async () => {\n  console.log('Кнопка Load More натиснута');\n\n  // Завантажую наступну сторінку (isFirstLoad = false)\n  await loadImages(false); // Очікую доки завантажаться наступні зображення\n});\n\n\n\n\n"],"names":["API_KEY","BASE_URL","PER_PAGE","getImagesByQuery","query","page","params","axios","error","galleryContainer","loadMoreButton","lightbox","createGallery","images","markup","webformatURL","largeImageURL","tags","likes","views","comments","downloads","SimpleLightbox","clearGallery","hideLoadMoreButton","showLoadMoreButton","form","input","loader","gallery","currentQuery","currentPage","totalHits","isLoading","showLoader","hideLoader","delay","ms","resolve","loadImages","isFirstLoad","data","iziToast","firstCard","cardHeight","maxPages","event"],"mappings":"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"}